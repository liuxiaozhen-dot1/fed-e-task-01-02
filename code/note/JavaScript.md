JavaScript  性能优化

1. 内存管理 
内存：由可读单元组成，表示一片可操作的空间。 
管理：人为的去操作一片空间的申请，使用和释放。
内存管理：开发者主动申请空间和使用空间，释放空间。
管理流程：申请-使用-释放
JavaScript中的内存管理： 申请内存空间 使用内存空间 释放内存空间

2. JavaScript中的垃圾回收机制
JavaScript中的内存管理是自动的    对象不再被引用时就是垃圾    对象不能从根上访问时是垃圾
JavaScript中的可达对象
可以访问到的对象就是可达对象（引用 作用域链） 可达的标准时可以从根上找到  JavaScript中的根可以理解为是全局的变量对象  

3. GC算法介绍
GC垃圾回收机制的简写 GC可以找到内存中的垃圾并释放和回收空间 算法就是工作时查找和回收所遵循的规则
GC里的垃圾是什么？ 程序中不再使用的对象   程序中不再访问到的对象
常见的GC算法： 引用计数  标记清除  标记整理  分代回收

4. 引用计数算法
核心思想：设置引用数，判断当前的引用数是否为0
引用计数器
引用管理改变时修改引用数字
引用数字为0时立即回收
优点：发现垃圾时立即回收  最大限度减少程序暂停
缺点：无法回收循环应用的对象  时间开销大

5. 标记清除算法
核心思想：分标记和清除两个阶段完成
遍历所有的对象找标记活动对象
遍历所有对象清除没有标记的对象
回收相应的空间
优点：可以去解决循环引用不能回收的问题
缺点：空间碎片化的问题 不能使空间得到最大的使用  不会立即回收垃圾对象

6. 标记整理算法
核心思想：标记整理可以看作是标记清除的增强
标记阶段的操作和标记清除一致
清除阶段会先执行整理，移动对象的位置
优点：减少空间碎片化，使空间使用最大化
缺点：不会立即回收垃圾对象

7. V8
V8是一款主流的JavaScript执行引擎 V8采用即使编译 V8内存设限

8. V8垃圾回收策略
使用分代回收的思想  内存分为新生代和老生代 针对不同的对象采用不同的算法
V8中常用的GC算法：分代回收  空间复制 标记清除 标记整理 标记增量

9. V8如何回收新生代对象
V8内存空间一分为二
小空间用于存储新生的对象（32M|16M）
新生代指的是存活时间较短的对象

新生代对象回收实现：回收过程采用复制算法加标记整理  新生代内存区分为两个等大小空间 
使用空间为From 空闲空间为To   活动对象存储于From空间 标记整理后将活动对象拷贝至To  From与To交换空间完成释放

回收细节说明：拷贝过程中可能出现晋升  晋升就是将新生代对象移动至老生代 一轮GC还活着的新生代需要今生 To空间的使用率超过25%

9. V8如何回收老生代对象
老生代对象说明：老生代对象存放在右侧区域  64为操作系统中1.4G，32位操作系统700M  老生代对象生存时间较长的对象

老生代对象回收的实现：主要采用标记清除 标记整理 增量标记算法  
首先使用标记清除完成垃圾空间的回收   采用标记整理进行空间优化   采用增量标记进行效率优化

细节对比：新生代区域垃圾回收使用空间换时间  老生代区域垃圾回收不适合复制算法 

10. 为什么使用Performance
GC的目的是为了实现空间良性循环  良性循环的基石是合理利用  时刻关注才能确定是否合理  Performance提供多种监控方式

11. 内存问题的体现
页面出现延迟加载或者经常暂停  页面出现糟糕性能  页面性能随着时间延长越来越差 

12. 监控内存的几种方式
界定内存问题的标准：内存泄漏：内存的持续升高  ， 内存膨胀：在多数设备上都存在性能问题 ， 频繁的垃圾回收：通过内存变化图进行分析
监控的方式：浏览器任务管理器 ， TimeLine时序图记录 ， 堆快照分离DOM ， 判断是否存在频繁的垃圾回收

13. 慎用全局变量
全局变量定义在全局执行上下文，是所有作用域链的顶端
全局执行上下文一直存在于上下文指向栈，直到程序退出
如果某个局部作用域出现了同名变量则会遮蔽或者污染全局

14. 缓存全局变量
将使用中无法避免的全局变量缓存到局部可提高性能

15. 通过原型新增方法
在原型对象上新增实例对象所需要的方法

16. 避免闭包陷阱的使用  避免属性访问方法的使用 For循环优化操作

17. 文档碎片优化节点添加
节点的添加操作必然会有回流和重绘

18. 克隆优化节点操作

19. 直接量替换 new Object